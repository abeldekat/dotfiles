# Search sections: '# -'
# sxhkd
# bspwm hotkeys
# state/flags
# Focus and swap 
# preselect
# move/resize
# testing
#
# TODO rotate flip circulate insert-receptacle hidden en layer
# Note: Setting the split ratio of the parent internal node is a direct resize
# Note: st terminal,zoom text with TERMMOD: shift control pageup/down
#
# Search keys, example p: /\v\+ .*p
# 
# Key chord chains are used for less common or ancillary commands, or
# for when assigning direct keybindings would become unwieldy.  The idea
# is to scope bindings so as to avoid conflicts.
# Try to use shift for extending related functionality
#
# Overview letters prepended by the super key:
# a (CHAIN advanced) (focus node jump: p,b,comma,period) (set flags:lmsp)
# b (swap biggest)
# c (focus next) 
# d (dmenu)
# e (_common: CHAIN environment)
# f (fullscreen)
# g (_common: CHAIN gui applications)
# h j k l (navigation, replace, resize. Most important vim like keys)
# i (focus newer node in history)
# m (monocle)
# n (switch to visual mode)
# o (focus older node in history)
# p (CHAIN preselect using hjkl 0-9 and space)
# q AVAILABLE
# r AVAILABLE
# s (CHAIN split ratio, equalize, balance)
# t (tiled)
# u AVAILABLE
# v (CHAIN move selected windown hjkl)
# w (close or kill node)
# x (_common, terminal programs)
# y (sends marked to preselected area)
# z (CHAIN resiZe hjkl. Advantage over super-alt: No need to keep the keys pressed. Super-shift-alt is awkward. Disadvantage: Only continues key pressing on one operation, expand or contract. Needs escape and another 'z' to switch operation)
#
# space: (window state: switch to floating, pseudo-tiled)
# grave: (last focused node)
# bracked: (last focused desktop)
# escape: (reload sxhkd)
# alt (bspc quit restart: uses qr)
# alt (expand and contract : uses shift hjkl)
# {Left,Down,Up,Right} move floating window
# {0-9} focus desktop or send node to desktop
# delete: (_common lockscreen)

# ----
#  sxhkd
# ----

# Reload keyboard shortcuts with sxhkd. Resets to normal mode. Does not kill the process
super + Escape
	sxhkd-mirror-files ; \
	sxhkd-reload && \
	polybar-msg hook sxhkd-mode 1 && \
	notify-send "SXHKD" "config reloaded"

# Change config to visual mode
super + n
	sxhkd-modes-switch-files visual 1 ; \
	sxhkd-reload && \
	polybar-msg hook sxhkd-mode 2 > /dev/null

# ----
# bspwm hotkeys
# ----

# Standard
# quit/restart bspwm
super + alt + {q,r}
	bspc {quit,wm -r}

# Standard
# close or kill the windows rooted at the selected node.
super + {_,shift + }w
	bspc node -{c,k}

# Standard
# alternate between the tiled and monocle desktop layout
super + m
	bspc desktop -l next

# Standard
# -n is to-node
# send the newest marked node to the newest preselected node on the ***current*** desktop
super + y
	bspc node newest.marked.local -n newest.!automatic.local

# Not standard, uses g on any biggest window
# TODO This is quick operation which can also be done with hjkl
# Note: super + g is already in use, see _common
# swap the current node and the biggest existing window on current desktop
super + b
	bspc node -s biggest.local

# ----
# state/flags
# ----

# Standard
# set the window state
# super + {t,shift + t,s,f}
# 	bspc node -t {tiled,pseudo_tiled,floating,fullscreen}
#
# Not standard,protsdots, frees letter s
# Toggle tiled, pseudo_tiled, floating, fullscreen view.  Tiled is what
# is used by default.  Pseudo-tiled presents the window in its original
# dimensions inside the split it would normally occupy as a tile.  
# Floating windows have their own dimensions and can be stacked on top of each other.
# NOTE the presence of the tilde ~.  If current state matches the given
# state, then the argument is interpreted as the last state.
#
# set the window state
super + {t,shift + space,space,f}
 	bspc node -t '~{tiled,pseudo_tiled,floating,fullscreen}'

# Not standard, super + control + mxyz
# Note: super-control was used by preselect, now with p keychord
# TODO no hidden flag
# set node flags: marked,locked, sticky,private
super + a ; {l,m,s,z}
	bspc node -g {locked,marked,sticky,private}

# Not standard, protsdots
# Applies to the next window, or when using the next set of commands that equalise the tree or balance the
# parent node.
# Set the split ratio on demand.
super + s ; {1,2,3,4,5}
	bspc config split_ratio { \
	0.25 && notify-send "BSPWM configuration" "Split ratio set to 0.25", \
	0.34 && notify-send "BSPWM configuration" "Split ratio set to 0.34", \
	0.50 && notify-send "BSPWM configuration" "Split ratio set to 0.50", \
	0.66 && notify-send "BSPWM configuration" "Split ratio set to 0.66", \
	0.75 && notify-send "BSPWM configuration" "Split ratio set to 0.75" \
	}

# Not standard, protsdots
# Equalize applies to the root of the tree.
# Balance applies to the parent node to even out manually-split windows.
# Man equalize: Reset the split ratios of the tree rooted at the selected node to their default value.
# Man balance: Adjust the split ratios of the tree rooted at the selected node so that all windows occupy the same area.
# Make node split ratios equal or balance
super + s ; {e,b}
	bspc node {@/ --equalize,@parent --balance}

# ----
# Focus and swap 
# ----

# Standard
# TODO nice to have: prot smart move script, creates receptacles when there is no 
# window in the given direction.
# focus or swap the node in the given direction
super + {_,shift + }{h,j,k,l}
	bspc node -{f,s} {west,south,north,east}

# Not standard, without the a directly on super
# Advanced namespace focus operations
# focus the node for the given path jump:parent, brother, first, second
super + a ; {p,b,comma,period}
	bspc node -f @{parent,brother,first,second}

# Standard
# man: Selects the node in the given (cyclic) direction relative to the reference node within a depth-first in-order traversal of the tree.
# Cyclic behaviour
# Old way: focus the next/previous node in the current desktop
# bspc node -f {next,prev}.local
# focus foCus the next/previous window in the current desktop
super + {_,shift + }c
	bspc node -f {next,prev}.local.!hidden.window

# Standard
# Cyclic
# focus the next/previous desktop in the current monitor
super + bracket{left,right}
	bspc desktop -f {prev,next}.local

# Standard
# focus the last focused node/desktop
super + {grave,Tab}
	bspc {node,desktop} -f last

# Standard
# focus older or newer node in focus history
super + {o,i}
	bspc wm -h off; \
	bspc node {older,newer} -f; \
	bspc wm -h on

# Standard
# node -d: means to-desktop
# focus desktop or send to the given desktop without requesting focus
super + {_,shift + }{1-9,0}
	bspc {desktop -f,node -d} '^{1-9,10}'

# ----
# preselect
# ----

# Not Standard, tilde cancels preselection
# Thus, bspc node -p cancel is redundant
# A node with a preselected area is said to be in "manual insertion mode".
# super + ctrl + {h,j,k,l}
# preselect the direction
super + p ; {h,j,k,l}
	bspc node -p '~{west,south,north,east}'

# Not Standard
# super + ctrl + {1-9}
# Set the splitting ratio of the preselection area to 0.1 to 0.9
super + p ; {1-9}
	bspc node -o 0.{1-9}

# Not Standard
# super + ctrl + space
# 	bspc node -p cancel
# super + ctrl + shift + space
# 	bspc query -N -d | xargs -I id -n 1 bspc node id -p cancel
# cancel the preselection for the focused node or desktop
super + p ; space
	bspc query -N -d | xargs -I id -n 1 bspc node id -p cancel

# ----
# move/resize
# ----

# Standard
# resize: expand a window by moving one of its side outward
super + alt + {h,j,k,l}
	bspc node -z {left -20 0,bottom 0 20,top 0 -20,right 20 0}
# Not standard
# resize continuesly: expand a window by moving one of its side outward
super + z : {h,j,k,l}
	n=20; bspc node -z {left -$n 0,bottom 0 $n,top 0 -$n,right $n 0}

# Standard
# A vim mode would be great here. Four keys!
# resize: contract a window by moving one of its side inward
super + alt + shift + {h,j,k,l}
	bspc node -z {right -20 0,top 0 20,bottom 0 -20,left 20 0}
# Not standard
# resize continuesly: contract a window by moving one of its side inward
super + z : {H,J,K,L}
	n=20; bspc node -z {right -$n 0,top 0 $n,bottom 0 -$n,left $n 0}


# > Will always grow for floating nodes. <
# Decision: Not really useful yet
# Smart resize, will grow or shrink depending on location.
# super + ctrl + alt + {h,j,k,l}
# 	n=10; \
#   	{ d1=left;   d2=right;  dx=-$n; dy=0;   \
#   	, d1=bottom; d2=top;    dx=0;   dy=$n;  \
#   	, d1=top;    d2=bottom; dx=0;   dy=-$n; \
#   	, d1=right;  d2=left;   dx=$n;  dy=0;   \
#   } \
#   bspc node --resize $d1 $dx $dy || bspc node --resize $d2 $dx $dy


# Standard
# move a floating window
super + {Left,Down,Up,Right}
	bspc node -v {-20 0,0 20,0 -20,20 0}
# Not standard
# continuesly move a floating window
super + v : {h,j,k,l}
	bspc node -v {-20 0,0 20,0 -20,20 0}

# ---
# Misc
# ---

# TODO Vimlike only: Keep the focussed node and close all others 
# super + z ; o
# 	bspc query --nodes --node .\!focused.leaf | xargs -I id bspc node id -c

# ----
# Testing:
# ----

# super + v ; {a,b} : {c,d}
# 		notify-send {"a","b"} \
# 	 	{ \
# 			"ac", "bc", \ 
# 			"ad", "bd" \
# 		}
# super + v ; {a,b} : {c,d}
# 	 	{ \
# 			notify-send "t" "ac", notify-send "t" "bc", \ 
# 			notify-send "t" "ad", notify-send "t" "bd" \
# 		} 
# notify-send "test" {"ac","bc","ad","bd"}
